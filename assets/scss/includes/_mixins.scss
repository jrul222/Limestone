@import "mixins/m_layout";
@import "mixins/m_typography";
@import "mixins/m_flex";

/*------------------------------------*\
    $MIXINS
\*------------------------------------*/

@mixin shield ($shield-color, $align: 'left') {
	$shield-width: 70px;
	$shield-height: $shield-width / 1.5;

	$left-value: '';
	$right-value: auto;
	@if ($align == 'left') {
		// put it at the "left" of the block
		// default matches callout style: padding 40px
		$left-value: 40px;
	} @else if ($align == 'center' ) {
		// center it horizontally
		$left-value: 0;
		$right-value: 0;
	} @else {
		// accept an explicit pixel value
		$left-value: $align;
	}

	position: relative;
	padding-top: rem-calc($shield-height + 30px);
	.shield-icon {
		display: inline-block;
		position: absolute;
		z-index: 3;
		top: 0;
		@if ($align == 'left') {
			left: $left-value + 15;
		} @else {
			left: $left-value;
		}
		right: $right-value;
		margin: auto;
		width: 36px;
		height: 36px;
		svg {
			max-width: 100%;
			max-height: 100%;
			color: #fff;
			fill: #fff;
		}
	}
	&:before,
	&:after {
		display: block;
		content: '';
		position: absolute;
		left: $left-value;
		right: $right-value;
		margin: auto;
	}
	&:before {
		width: $shield-width;
		height: $shield-height / 1.5;
		top: 0;
		// left: $callout-padding;
		background: $shield-color;
		z-index: 2;
	}
	&:after {
		width: 0;
		height: 0;
		// top: $shield-height - $callout-stroke-width;
		top: 31px;
		// top: 0;
		// left: $callout-padding + rem-calc(1);
		// border: ($shield-height - $callout-stroke-width) solid transparent;
		// border-top-color: $default-stroke;

		$hex-size: 34px;
		border-left: $hex-size solid transparent;
		border-right: $hex-size solid transparent;
		border-top: $hex-size/2 solid $shield-color;
	}
	&.dark {
		&:before {
			background: $dark-stroke;
		}
		&:after {
			border-top-color: $dark-stroke;
		}
	}
}


// generate the image url by prefixing the layout image path
@function image-url($url) {
  @return url("#{$image-url-path}#{$url}");
}

// style input placeholders
@mixin placeholder {
  &::-webkit-input-placeholder {@content}
  &:-moz-placeholder           {@content}
  &::-moz-placeholder           {@content}
  &:-ms-input-placeholder      {@content}
}

@mixin ornament-above {
	margin-top: $ornament-size / 2;
	padding-top: $ornament-size / 2;
	position: relative;

	.ornament {
		left: 50%;
		position: absolute;
		top: 0;
		transform: translateX(-50%) translateY(-50%);
	}
}

@mixin ornament-below {
	margin-bottom: $ornament-size / 2;
	padding-bottom: $ornament-size / 2;
	position: relative;

	.ornament {
		bottom: 0;
		left: 50%;
		position: absolute;
		transform: translateX(-50%) translateY(50%);
	}
}

// Stretch an element (usually a <figure>) and its child image to fill the
// element's parent container
//
// Options:
//		$beneath[true|false] default: false
//				If true, places the stretched element underneath its siblings. Useful
//				for image backgrounds.
//
//		$fill['width'|'height'|'both']
//			'width'		:	Image stretches to fill parent width, height scales proportionally
//			'height'	:	Image stretches to fill parent height, width scales proportionally
//			'both'		:	Image stretches to fill the shorter of width or height, cropping the
//									longer dimension
//
//		$pin['left'|'right'|'center' 'top'|'bottom'|'center'] default: 'top' 'center'
//			When the image must be cropped to fit, this determines which vertical and
//			horizontal side will remain unchanged. If 'center', then both sides are cropped
//			equally.


@mixin pseudo-cover ($beneath:false, $fill: 'both', $pin:'center' 'top') {
	width: 100%;
	max-width: none;
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	content: '';
	display: block;

	margin: 0;

	@if $beneath {
		z-index: 0;
	}

	> img {
		position: absolute;

		max-width: none;
		max-height: none;

		@if ($fill == 'width') {
			width: 100%;
			height: auto;
			min-height: none;
		} @else if ($fill == 'height') {
			width: auto;
			min-width: none;
			height: 100%;
		} @else {
			width: auto;
			min-width: 100%;
			height: auto;
			min-height: 100%;
		}


		@if( nth($pin, 1) == 'center' ) {
			right: auto;
			left: 50%;
			transform: translateX(-50%);
		} @else if( nth($pin, 1) == 'right' ) {
			right: 0;
			left: auto;
		} @else {
			right: auto;
			left: 0;
		}


		@if( nth($pin, 2) == 'center' ) {
			top: 50%;
			@if( nth($pin, 1) == 'center' ) {
				transform: translate(-50%, -50%);
			} @else {
				transform: translateY(-50%);
			}
		} @else {
			top: 0;
			bottom: 0;
		}
	}
}


// Use in conjunction with pseudo-cover. Applies a color to an image container.
// If mix-blend-mode is supported by the browser, a color layer will be applied
// above the image with the 'multiply' blend mode (blend mode can be changed
// using $mode argument). If the browser does not support mix-blend-mode
// (e.g. IE and Edge), the image will be made partially transparent
// on top of a colored layer. The effect is similar, but not identical.
// A modernizr function to check for mix-blend-mode is required for this
// mixin to function fully.
//
// Arguments:
//	$color[color hex value] default: primary theme color
//	$opacity[decimal value between 0 and 1] default: $opacity-overlay variable
//	$mode['multiply'|'overlay'|'screen'] default: 'multiply'

@mixin color-overlay($color:$color-primary, $opacity:$opacity-overlay, $mode:multiply) {
	&::after {
		@include pseudo-cover;
		background-color: rgba($color, $opacity);
	}

	.mix-blend-mode & {
		> img {
			opacity: $opacity * 0.5;
		}

		&::after {
			background-color: $color;
			mix-blend-mode: $mode;
		}
	}
}


// Simple variant of color overlay. Darkens the contents of an element
// by placing a semi-transparent black (or specified color) layer on
// top of it.
@mixin dark-bg-image($color:#000, $opacity:$opacity-overlay) {
	&::after {
		@include pseudo-cover;
		background-color: rgba($color, $opacity);
	}
}

// Similar to dark-bg-image, uses a gradient from black (or specified color) to
// transparent instead of a solid color layer.
@mixin gradient-overlay($color:#000, $direction:to right, $distance:50%, $opacity:0) {
	&::after {
		@include pseudo-cover;
		background-image: linear-gradient($direction, $color, $color $distance, rgba($color, $opacity));
	}
}


// Background image of a horizontal line, made up of dots.
// Arguments:
//		$size[pixel value] default: set in variables file
//			Size of a single dot in pixels
//
//		$spacing[float]	default: set in variables file
//			Size ratio of space between dots to dot size. Larger value means bigger space between dots.
//
//		$color[color hex value] default: set in variables file
//			Color of dots
@mixin line-dotted($size:$border-dot-size, $spacing:$border-dot-spacing, $color:$border-dot-color) {

	$radius: $size / 2;
	$space-width: $spacing * $size;

	$image-horizontal: "data:image/svg+xml;utf8,<svg width='#{$size + $space-width}' height='#{$size}' viewBox='0 0 #{$size + $space-width} #{$size}' xmlns='http://www.w3.org/2000/svg'><ellipse fill='#{$color}' cx='#{$radius}' cy='#{$radius}' rx='#{$radius}' ry='#{$radius}'/></svg>";

	background-image: url($image-horizontal);
	background-repeat: repeat-x;
	background-position: center center;
	background-size: #{$size + $space-width}px auto;

}

// Similar to line-dotted, this mixin puts a dotted border around an element on any or all sides.
// Takes same arguments as line-dotted, and also:
// 	$sides[up to 4 strings] default: 'top' 'right' 'bottom' 'left'
//		Border is applied only to the sides listed in this argument.

$dotted-border-sides-default: 'top' 'right' 'bottom' 'left';

@mixin border-dotted($size:$border-dot-size, $spacing:$border-dot-spacing, $color:$border-dot-color, $sides:$dotted-border-sides-default) {
	$radius: $size / 2;
	$space-width: $spacing * $size;

	$image-size: $size * 3 + $space-width * 2;

	$image-border: "data:image/svg+xml;utf8,<svg width='#{$image-size}' height='#{$image-size}' viewBox='0 0 #{$image-size} #{$image-size}' xmlns='http://www.w3.org/2000/svg'><g fill='#{$color}'><ellipse cx='#{$radius}' cy='#{$radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{$size + $space-width + $radius}' cy='#{$radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{($size * 2) + $space-width * 2 + $radius}' cy='#{$radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{$radius}' cy='#{$size + $space-width + $radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{($size * 2) + $space-width * 2 + $radius}' cy='#{$size + $space-width + $radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{$radius}' cy='#{($size * 2) + ($spacing * $size * 2) + $radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{$size + $space-width + $radius}' cy='#{($size * 2) + $space-width * 2 + $radius}' rx='#{$radius}' ry='#{$radius}'/><ellipse cx='#{($size * 2) + $space-width * 2 + $radius}' cy='#{($size * 2) + $space-width * 2 + $radius}' rx='#{$radius}' ry='#{$radius}'/></g></svg>";

	border-width: 0;
	border-style: solid;
	border-image: url($image-border) 33% round;

	@each $side in $sides {
		border-#{$side}-width: #{$radius + $space-width}px;
	}

}
